name: Release

on:
  push:
    tags:
      - "*"
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_run:
    workflows: ["Build and Test"]
    types:
      - completed

jobs:
  build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Generate Release Note
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          wget --header="Authorization: Bearer ${GITHUB_TOKEN}" ${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/releases\?per_page\=1 -O releases.json
          cat releases.json | jq
          LATEST_TAG=`cat releases.json | jq -r '.[0].tag_name'`
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            NEXT_TAG=`echo ${GITHUB_REF} | grep -E -o '[0-9]+\.[0-9]+\.[0-9]+'`
            echo "# Release ${NEXT_TAG}" > release_note.md
            echo "" >> release_note.md
            echo "## Changes from \`${LATEST_TAG}\` to \`${NEXT_TAG}\`" >> release_note.md
            echo "" >> release_note.md
            git log --pretty="* %h - %s" ${LATEST_TAG}..${NEXT_TAG} | tee -a release_note.md
          else
            HEAD_HASH=`git rev-parse --short HEAD`
            echo "# Development Build" > release_note.md
            echo "" >> release_note.md
            echo "## Changes from \`${LATEST_TAG}\` to \`${HEAD_HASH}\`" >> release_note.md
            echo "" >> release_note.md
            git log --pretty="* %h - %s" ${LATEST_TAG}..HEAD | tee -a release_note.md
          fi
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable
      - name: Setup
        env:
          API_KEY: ${{ secrets.API_KEY }}
          GOOGLE_APP_ID: ${{ secrets.GOOGLE_APP_ID }}
          GCM_SENDER_ID: ${{ secrets.GCM_SENDER_ID }}
        run: |
          ./setup.sh
      - name: Restore Build Cache
        uses: actions/cache@v3
        with:
          path: build
          key: build-cache-${{ runner.os }}-${{ matrix.os }}-${{ matrix.arch }}-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            build-cache-${{ runner.os }}-${{ matrix.os }}-${{ matrix.arch }}-
      - name: Archive
        run: |
          xcodebuild clean archive \
            -scheme mpvx \
            -configuration Release \
            -archivePath build/mpvx.xcarchive \
            -destination "platform=macOS"
          mkdir -p build/Build/Products/Release
          cp -R build/mpvx.xcarchive/Products/Applications/mpvx.app build/Build/Products/Release/mpvx.app
      - name: Save Build Cache
        uses: actions/cache@v3
        with:
          path: build
          key: build-cache-${{ runner.os }}-${{ matrix.os }}-${{ matrix.arch }}-${{ hashFiles('**/Package.resolved') }}
      - name: Install create-dmg
        run: |
          brew install create-dmg
      - name: Create .dmg with Applications folder
        run: |
          mkdir -p dist
          create-dmg \
            --volname "mpvx" \
            --window-pos 200 200 \
            --window-size 600 400 \
            --icon-size 100 \
            --app-drop-link 400 200 \
            --icon "mpvx.app" 200 200 \
            ./dist/mpvx.dmg \
            ./build/Build/Products/Release/mpvx.app
      - name: Download Sparkle CLI (version from Package.resolved)
        run: |
          # Extract Sparkle version from Package.resolved
          SPARKLE_VERSION=$(jq -r '.pins[] | select(.identity == "sparkle") | .state.version' \
            mpvx.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved)
          if [ -z "$SPARKLE_VERSION" ]; then
            echo "Error: Could not determine Sparkle version from Package.resolved."
            exit 1
          fi
          echo "Detected Sparkle version: $SPARKLE_VERSION"
          # Construct download URL
          DOWNLOAD_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-for-Swift-Package-Manager.zip"
          echo "Downloading Sparkle CLI from \`${DOWNLOAD_URL}\`..."
          # Download and unzip Sparkle CLI
          wget -O /tmp/Sparkle-for-Swift-Package-Manager.zip "${DOWNLOAD_URL}"
          echo "Unzipping Sparkle CLI to \`/tmp/sparkle\`..."
          unzip /tmp/Sparkle-for-Swift-Package-Manager.zip -d /tmp/sparkle
          # Make CLI tools executable
          echo "Making CLI tools executable..."
          chmod +x /tmp/sparkle/bin/generate_appcast
          chmod +x /tmp/sparkle/bin/sign_update
          # Copy CLI tools to the workspace
          echo "Copying CLI tools to \`${GITHUB_WORKSPACE}\`..."
          cp /tmp/sparkle/bin/generate_appcast $GITHUB_WORKSPACE/
          cp /tmp/sparkle/bin/sign_update $GITHUB_WORKSPACE/
      - name: Decode and save private key
        run: |
          echo "${{ secrets.SPARKLE_ED25519_PRIVATE_BASE64 }}" | base64 --decode > ed25519_private.pem
          chmod 600 ed25519_private.pem
      - name: Fetch existing appcast
        run: |
          mkdir -p dist/appcast
          echo "Fetching existing appcast.xml from https://mpvx.hackinggate.com/appcast.xml ..."
          curl -fSL "https://mpvx.hackinggate.com/appcast.xml" -o dist/appcast/appcast.xml \
            || echo "No existing appcast.xml found at https://mpvx.hackinggate.com/appcast.xml."
      - name: Get Tag
        id: get_tag
        run: echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
      - name: Generate Appcast
        run: |
          mkdir -p dist/appcast
          echo "Generating appcast (with signing enabled) ..."
          ./generate_appcast \
            --ed-key-file ed25519_private.pem \
            -o dist/appcast/appcast.xml \
            --download-url-prefix "https://github.com/${{ github.repository }}/releases/download/${{ steps.get_tag.outputs.tag }}/" \
            dist
      - name: Upload .dmg artifact
        uses: actions/upload-artifact@v4
        with:
          name: mpvx.dmg
          path: ./dist/mpvx.dmg
      - name: Upload appcast artifact
        uses: actions/upload-artifact@v4
        with:
          name: appcast
          path: ./dist/appcast/appcast.xml
      - name: Upload release note
        uses: actions/upload-artifact@v4
        with:
          name: release_note.md
          path: ./release_note.md
      - name: Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ./dist/mpvx.dmg
            ./dist/appcast/appcast.xml
          body_path: release_note.md
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
